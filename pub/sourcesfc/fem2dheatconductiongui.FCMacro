# -*- coding: utf-8 -*-
# GUI for 2D FEM heat conduction inside of FreeCAD
# Author: teobo
# 
# License: LGPL v 2.1
# Version: 04/12/2015

# CONFIGURATION - EDIT THE FOLLOWING LINE TO MATCH YOUR GMSH BINARY
gmsh_bin = "/usr/bin/gmsh"
# END CONFIGURATION

# START OF MACRO
from PySide import QtGui, QtCore
import Fem
import FemGui
import FemAnalysis
import FreeCAD
import FreeCADGui
import ImportGui
import Mesh
import subprocess
import sys
import tempfile


class MeshGmsh(QtGui.QWidget):
    def __init__(self):
        super(MeshGmsh, self).__init__()
        self.initUI()

    def __del__(self):
        return

    def initUI(self):
	#Stage 1
	self.cmb_source1 = QtGui.QComboBox(self)
        self.algorithm_list = [self.tr('DINENISO10211_1'), self.tr('...10211_2 2bimplemented'), ]
        self.cmb_source1.addItems(self.algorithm_list)
        self.cmb_source1.setCurrentIndex(0)
        # Trigger button stage 1
        self.stage1trigger = QtGui.QPushButton(self)
        self.stage1trigger.setText("mkface(1)")
        self.stage1trigger.setToolTip("construct, prepare workflow piece\ncompound from demo pointlist \n in listDocuments?newDocument(fc_docname) \n makefacefrompointsL")

        # Trigger button stage 2
        self.stage2trigger = QtGui.QPushButton(self)
        self.stage2trigger.setText("addVert(2)")
        self.stage2trigger.setToolTip("prepare selected or workflow compound \nwith additional points for conforming meshing in next stage ")

        # Trigger button stage gmsh_mesh(3)
        self.gmsh_meshing = QtGui.QPushButton(self)
        self.gmsh_meshing.setText("gmsh_mesh(3)")
        self.gmsh_meshing.setToolTip("mesh selected or workflow piece to femmesh object\n using external solver gmsh: \nhttp://geuz.org/gmsh/doc/texinfo/gmsh.html#Mesh\nline = self.le_cmd_line_opt_mesh.text() \nMaxSize=,MinSize,algoname\n -gmshmesh\n apt-get install gmsh\n -make_topo_edge :visualize mesh edges") 
	
	# Trigger annotate_all 4
        self.annotate_all = QtGui.QPushButton(self)
        self.annotate_all.setText("anno_all(4)")
	self.annotate_all.setToolTip("A:no workflow, just visus\n B:annotate nodes elements edges, activate by hitting space in combo view\n \
	in general is it easier (then spending time in\n programming a gui for debug and demo purposes and\n for the user learning doubtful limiting syntax)\n doing the accessing (whatever!) visualization\n (annotation) from the command line\n \
	look for templates in the demo scripts:\n anno7=pointtopost.visu_annotate_note(Pi.femmesh2,[],['T:'+str(round(float(j),2))\n \ for j in Pi.solutiondata[0][0]]) \n anno7.Label='Ann_resultT_N_'+\n \'Pi'+str(Pieces.index(Pi))\n \
	Systematic: There the pattern: a) selected mesh\n \ things (1nodes, 2elements, 3mesh boundary edges\n \, 4topo faces=bodies, 5topo edges) b) selection of the former: all, gui selected, lists, neighbors\n \ elements of edges, double nodes, double edges,\n \ etc c) you got according to case of a \n (modifiable) annotation strings which is\n \ 1:list_id,id,Temperature, any_result_value 2:\n \
	list,id,k_value, Materialname,body_id,neighbor\n \
	nodes,Energyflux,whatever_resultvalue\n \
	3:listid,id,external Temperature,Rsi\n \
	-value,Boundary-group, etc\n \
	d) Then you got to consider occasions or stages\n \
	when you need and that require certain annotation\n  style: registering boundary conditions (7),\n \
	checking for mesh inconsistancy such as doubles\n \
	(6), postprocessing (12), debugging the\n \
	exporter/importer for a solver(9)\n \
	For example the template above is a) nodes b) \n all c)annotate Temperature results\n \
	d)postprocessing \n \
	Hint: activate anno-stack with space key\n \
	Hint: set digit 2 in general flag vector to enable taking sources form arbitrary femmesh objects")
        # Trigger annotate_doubles 5
        
        self.annotate_doubles = QtGui.QPushButton(self)
        self.annotate_doubles.setText("anno_dbl(5)")
        self.annotate_doubles.setToolTip("A)Workflow: calculate result for next stage:\n -checkfordoublenodes\n -finddoubleedges \n  B) Visu: -compare tooltip anno_all(4)/n -visu_annotate_note\n  no double found? all will be annotated..\n-visu_annotate_edge_element")


        # Trigger doubles_elimination 6
        self.doubles_elimination = QtGui.QPushButton(self)
        self.doubles_elimination.setText("del_dbls(6)")
        self.doubles_elimination.setToolTip("and remshing to a new object: Pi.femmesh2")

        # Trigger button register_bodies_boundaries 7
        self.register_bodies_boundaries = QtGui.QPushButton(self)
        self.register_bodies_boundaries.setText("reg_groups(7)")
        self.register_bodies_boundaries.setToolTip("prototype passthroug: \n1)assign default boundaries to internal structure\n Pi.bnd_tegdeL, Pi.Bnds, Pi.Bodies= pointtopost.register_bodies_and_boundaries\n2)calculate results of boundary assignment for next stage (export to solver)\n get_edgegroup_and_neighbor \n get_elementbodysflag\n get_bnd_nodesbytedge\n getnodesbycompoundface\ngetnodesbycompoundedge\n3) visualize topo edge\n visu_bnd_tedge")

        # Trigger button register_bodies_boundaries 7
        self.init_reg_bnd = QtGui.QPushButton(self)
        self.init_reg_bnd.setText("init_reg(7.1)")
        self.init_reg_bnd.setToolTip("initial registering hardcoded defaults\n of boundary conditions): \n1)Dataflow model\n csv--spreadsheet--pi--gui\n here:write defaults to: csv,spreadsheet,pi,gui\n -visu_bnd_bodies \n -visu_bnd_tedge \n -open_spreadsh_csv(write \n .write_bnd_pi_to_spreadsheet")

        # Trigger button register_bodies_boundaries 7
        self.reg_save = QtGui.QPushButton(self)
        self.reg_save.setText("reg_save(7.2)")
        self.reg_save.setToolTip("A:save boundaries from spreadsheet\n A1:flag 3 set:read from cvs \n1)Dataflow model\n csv--spreadsheet--pi--gui\n here:write spreadsheet to: csv,pi,gui\n - \n -visu_bnd_tedge \n  \n B: prepare calculation for next stage")

        # Trigger annotate_boundary_neighbor_and_edgegroup 8
        self.annotate_boundary_neighbor_and_edgegroup = QtGui.QPushButton(self)
        self.annotate_boundary_neighbor_and_edgegroup.setText("anno_neig(8)")

        # Trigger export_to_elmer 9
        self.export_to_elmer = QtGui.QPushButton(self)
        self.export_to_elmer.setText("export(9)")

        # Trigger writing_sif_file 10
        self.writing_sif_file = QtGui.QPushButton(self)
        self.writing_sif_file.setText("write_sif(10)")

        # Trigger button fem_process 11
        self.fem_process = QtGui.QPushButton(self)
        self.fem_process.setText("fem_process(11)")

        # Trigger button annotate_t_results 12
        self.annotate_t_results = QtGui.QPushButton(self)
        self.annotate_t_results.setText("anno_T(12)")
        
        # Trigger button annotate_t_results 13
        self.deletesel = QtGui.QPushButton(self)
        self.deletesel.setText("del sel")
        self.deletesel.setToolTip("delete selected (default) objects with child")

        self.le_cmd_line_opt_flag = QtGui.QLineEdit(self)
        self.le_cmd_line_opt_flag.setToolTip("this general flag controlls the workflow.\n last digit 1: gui-selection regarded for workflow(1 on, 0 off) \n penultimate digit 2: gui-selection of femmeshes regarded for visualisation(1 on, 0 off) \n3: read boundary conditions(stage7) (0 from spreadsheet, 1 from cvs-file\neg. 100101 means selection based workflow on, selection based gui visualization off,boundary condition read from file\n examples: Workflow from demo pointlist (1) (2) (3) .. \n from selected object (2) (3)..")
        self.le_cmd_line_opt_flag.setText("100001")

        self.le_cmd_line_opt_mesh = QtGui.QLineEdit(self)
        self.le_cmd_line_opt_mesh.setToolTip("mesh option (3)\n 1: gmsh =2.2 =0.1 =auto\n(maxsize, minsize, algo or:\ngmsh =1.2 =0.05 =auto \n2:netgen radius to be implemented ")
        self.le_cmd_line_opt_mesh.setText("gmsh =2.2 =0.1 =auto")


        ## Trigger button stage gmsh 3
        #self.stage2trigger = QtGui.QPushButton(self)
        #self.stage2trigger.setText("addVert(2)")

       ## Mesh dimension
        #self.rb_1D = QtGui.QRadioButton("  f 45D", self)
        #self.rb_2D = QtGui.QRadioButton("   2D", self)
        #self.rb_3D = QtGui.QRadioButton("   3D", self)
        #self.rb_3D.setChecked(QtCore.Qt.Checked)
        ## Optimized:
        #self.cb_optimized = QtGui.QCheckBox("    Optimized", self)
        #self.cb_optimized.setChecked(QtCore.Qt.Checked)
        ## Create Mechanical Analysis from mesh
        #self.cb_mec_anal = QtGui.QCheckBox("    Create Mechanical Analysis from mesh",self)
        ##self.cb_mec_anal.setChecked(QtCore.Qt.Checked)
        ## Algorithm:
        #self.l_algorithm = QtGui.QLabel("Algorithm ", self)
        ## Format:
        #self.l_format = QtGui.QLabel("Format ", self)
        #self.cmb_format = QtGui.QComboBox(self)
        #self.format_list = [self.tr('unv'), self.tr('stl'), self.tr('med')]
        #self.cmb_format.addItems(self.format_list)
        #self.cmb_format.setCurrentIndex(0)
        #self.stored_cmb_format_index = 0
        ## Element max size:
        #self.cb_max_elme_size = QtGui.QCheckBox("  Set maximum mesh element size",self)
        #self.cb_max_elme_size.setChecked(QtCore.Qt.Checked)
        #self.sb_max_element_size = QtGui.QDoubleSpinBox(self)
        #self.sb_max_element_size.setValue(5.0)
        #self.sb_max_element_size.setMaximum(10000000.0)
        #self.sb_max_element_size.setMinimum(0.00000001)
        ## Element min size:
        #self.cb_min_elme_size = QtGui.QCheckBox("  Set minimum mesh element size",self)
        #self.sb_min_element_size = QtGui.QDoubleSpinBox(self)
        #self.sb_min_element_size.setValue(1.0)
        #self.sb_min_element_size.setMaximum(10000000.0)
        #self.sb_min_element_size.setMinimum(0.00000001)
        #self.sb_min_element_size.setEnabled(False)
        ## Set Mesh Order:
        #self.cb_mesh_order = QtGui.QCheckBox("  mesh order",self)
        #self.cb_mesh_order.setChecked(QtCore.Qt.Checked)
        #self.sb_mesh_order = QtGui.QSpinBox(self)
        #self.sb_mesh_order.setValue(2)
        #self.sb_mesh_order.setMaximum(5)
        #self.sb_mesh_order.setMinimum(1)
        ## Other gmsh commands:
        #self.l_cmd_line_opt = QtGui.QLabel("Custom gmsh options ", self)
        #self.le_cmd_line_opt = QtGui.QLineEdit(self)
        #self.le_cmd_line_opt.setToolTip("Those option will be appended to gmsh command line call")
        ## Ok buttons:
        #self.okbox = QtGui.QDialogButtonBox(self)
        #self.okbox.setOrientation(QtCore.Qt.Horizontal)
        #self.okbox.setStandardButtons(QtGui.QDialogButtonBox.Cancel | QtGui.QDialogButtonBox.Ok)
        # Layout:
        loffs=12 #layout offset
        layout = QtGui.QGridLayout()
        layout.addWidget(self.stage1trigger, 0, 1)
        layout.addWidget(self.stage2trigger, 0, 2)
        layout.addWidget(self.gmsh_meshing, 1, 1)
        layout.addWidget(self.annotate_all, 1, 2)
        layout.addWidget(self.annotate_doubles, 2, 1)
        layout.addWidget(self.doubles_elimination, 2, 2)
        layout.addWidget(self.register_bodies_boundaries, 3, 1)
        layout.addWidget(self.annotate_boundary_neighbor_and_edgegroup, 3, 2)
        layout.addWidget(self.init_reg_bnd, 4, 1)
        layout.addWidget(self.reg_save, 4, 2)
        layout.addWidget(self.export_to_elmer, 5, 1)
        layout.addWidget(self.writing_sif_file, 5, 2)
        layout.addWidget(self.fem_process, 6, 1)
        layout.addWidget(self.annotate_t_results, 6, 2)
        layout.addWidget(self.cmb_source1, 0, 0)
        layout.addWidget(self.le_cmd_line_opt_flag, 1, 0)
        layout.addWidget(self.le_cmd_line_opt_mesh, 2, 0)
        layout.addWidget(self.deletesel, 7, 2)
        #layout.addWidget(self.rb_1D, loffs+1, 0)
        #layout.addWidget(self.rb_2D, loffs+1, 1)
        #layout.addWidget(self.rb_3D, loffs+2, 0)
        #layout.addWidget(self.cb_optimized, loffs+2, 1)
        #layout.addWidget(self.l_algorithm, loffs+3, 0)
        #layout.addWidget(self.l_format, loffs+4, 0)
        #layout.addWidget(self.cmb_format, loffs+4, 1)
        #layout.addWidget(self.cb_max_elme_size, loffs+5, 0)
        #layout.addWidget(self.sb_max_element_size, loffs+5, 1)
        #layout.addWidget(self.cb_min_elme_size, loffs+6, 0)
        #layout.addWidget(self.sb_min_element_size, loffs+6, 1)
        #layout.addWidget(self.cb_mesh_order, loffs+7, 0)
        #layout.addWidget(self.sb_mesh_order, loffs+7, 1)
        #layout.addWidget(self.cb_mec_anal, loffs+8, 0)
        #layout.addWidget(self.l_cmd_line_opt, loffs+9, 0)
        #layout.addWidget(self.le_cmd_line_opt, loffs+9, 1)
        #layout.addWidget(self.okbox, loffs+10, 1)
        self.setLayout(layout)
        # Connectors:
        #QtCore.QObject.connect(self.okbox, QtCore.SIGNAL("accepted()"), self.proceed)
        #QtCore.QObject.connect(self.okbox, QtCore.SIGNAL("rejected()"), self.cancel)
        self.stage1trigger.clicked.connect(self.gui_dinDINENISO10211_1topoints)
        self.stage2trigger.clicked.connect(self.add_points_in_compound)
        self.gmsh_meshing.clicked.connect(self.gui_gmsh_meshing)
        self.annotate_all.clicked.connect(self.gui_annotate_all)
        self.annotate_doubles.clicked.connect(self.gui_annotate_doubles)
        self.doubles_elimination.clicked.connect(self.gui_doubles_elimination)
        self.register_bodies_boundaries.clicked.connect(self.gui_register_bodies_boundaries)
        self.init_reg_bnd.clicked.connect(self.gui_init_reg_bnd) 
        self.reg_save.clicked.connect(self.gui_reg_save) 
        self.annotate_boundary_neighbor_and_edgegroup.clicked.connect(self.gui_annotate_boundary_neighbor_and_edgegroup)
        self.export_to_elmer.clicked.connect(self.gui_export_to_elmer)
        self.writing_sif_file.clicked.connect(self.gui_writing_sif_file)
        self.fem_process.clicked.connect(self.gui_fem_process)
        self.annotate_t_results.clicked.connect(self.gui_annotate_t_results)
        self.deletesel.clicked.connect(self.gui_removeobjectswithchildren)
        #self.stage2trigger.clicked.connect(self.add_points_in_compound)
        #self.stage2trigger.clicked.connect(self.add_points_in_compound)
        #self.cb_max_elme_size.stateChanged.connect(self.max_size_state)
        #self.cb_min_elme_size.stateChanged.connect(self.min_size_state)
        #self.cb_mesh_order.stateChanged.connect(self.mesh_order_state)
        
    #def max_size_state(self, state):   
        #if state == QtCore.Qt.Checked:
            #self.sb_max_element_size.setEnabled(True)
        #else:
            #self.sb_max_element_size.setEnabled(False)

    #def min_size_state(self, state):   
        #if state == QtCore.Qt.Checked:
            #self.sb_min_element_size.setEnabled(True)
        #else:
            #self.sb_min_element_size.setEnabled(False)
            
    #def mesh_order_state(self, state):   
        #if state == QtCore.Qt.Checked:
            #self.sb_mesh_order.setEnabled(True)
        #else:
            #self.sb_mesh_order.setEnabled(False)

    #def open_gmsh_options(self):
        #import webbrowser
        #webbrowser.open('http://www.geuz.org/gmsh/doc/texinfo/gmsh.html#Command_002dline-options')

    #def cancel(self):
        #self.close()
        #d.close()

    #def proceed(self):
        #temp_file = tempfile.mkstemp(suffix='.step')[1]
        #selection = FreeCADGui.Selection.getSelection()
        #if not selection:
            #QtGui.QMessageBox.critical(None, "GMSHMesh macro", "An object has to be selected to run gmsh!")
            #return
        ## Export a part in step format
        #ImportGui.export(selection, temp_file)
        #selection_name = selection[0].Name
        ## Mesh temporaly file
        #file_format = self.cmb_format.currentText()
        #temp_mesh_file = tempfile.tempdir + '/' + selection_name + '_Mesh.' + file_format
        ## OPTIONS GMSH:
        #clmax = self.sb_max_element_size.text()
        #clmin = self.sb_min_element_size.text()
        #cmd_line_opt = self.le_cmd_line_opt.text()
        #algo = self.cmb_source1.currentText()
        #mesh_order = self.sb_mesh_order.text()

        #if self.cb_optimized.isChecked():
            #cmd_optimize = ' -optimize'
        #else:
            #cmd_optimize = ''

        #if self.rb_3D.isChecked():
            #dim = ' -3 '
        #if self.rb_2D.isChecked():
            #dim = ' -2 '
        #if self.rb_1D.isChecked():
            #dim = ' -1 '
        #if self.cb_max_elme_size.isChecked():
            #max_size = ' -clmax ' + clmax
        #else:
            #max_size = ''
        #if self.cb_min_elme_size.isChecked():
            #min_size = ' -clmin ' + clmin
        #else:
            #min_size = ''
        #if self.cb_mesh_order.isChecked():
            #order = ' -order ' + mesh_order
        #else:
            #order = ''

        #options = ' -algo ' + algo + max_size + min_size + cmd_optimize + order + cmd_line_opt
        ## RUN GMSH
        #command = gmsh_bin + ' ' + temp_file + dim + '-format ' + file_format + ' -o ' + temp_mesh_file  + '' + options
        #FreeCAD.Console.PrintMessage("Running: {}".format(command))
        #try:
            #output = subprocess.check_output([command, '-1'], shell=True, stderr=subprocess.STDOUT,)
            #FreeCAD.Console.PrintMessage(output)
            #if file_format in ('unv', 'med'):
                #Fem.insert(temp_mesh_file, FreeCAD.ActiveDocument.Name)
            #if file_format == 'stl':
                #Mesh.insert(temp_mesh_file, FreeCAD.ActiveDocument.Name)
            #if self.cb_mec_anal.isChecked():
              #FMesh = App.activeDocument().ActiveObject
              #MechanicalAnalysis.makeMechanicalAnalysis('MechanicalAnalysis')
              #FemGui.setActiveAnalysis(App.activeDocument().ActiveObject)
              #App.activeDocument().ActiveObject.Member = App.activeDocument().ActiveObject.Member + [FMesh]
            #if self.rb_1D.isChecked():
              #FMeshG = Gui.ActiveDocument.ActiveObject
              #FMeshG.DisplayMode = "Elements & Nodes"
        #except:
            #FreeCAD.Console.PrintError("Unexpected error in GMSHMesh macro: {}".format(sys.exc_info()[0]))
        #finally:
            #try:
                #del temp_file
            #except:
                #pass
            #try:
                #del temp_mesh_file
            #except:
                #pass

    def gui_dinDINENISO10211_1topoints(self):
	#print "hi"
	if len(set(FreeCAD.listDocuments())&set([Pi.fc_docname]))==0:
	    FreeCAD.newDocument(Pi.fc_docname)
	Pi.occpointsL=pointtopost.dinDINENISO10211_1topoints()
	print "draw faces"
	Pi.compound0=makefacefrompointsL(Pi.occpointsL)
	Pi.compound0.Label=Pi.compound0name+"Pi"+str(Pieces.index(Pi))

    def add_points_in_compound(self):
	cmd_line_opt = self.le_cmd_line_opt_flag.text()
	#print cmd_line_opt
	selection = FreeCADGui.Selection.getSelection()
	if selection and (cmd_line_opt[len(cmd_line_opt)-1]=="1") :
	    Pi.compound0=selection[0]
	    print "read from selection"
	#last index 1? use selection
	Pi.compound1=pointtopost.addpointstoface(Pi.compound0)
	Pi.compound1.Label=Pi.compound1name+"Pi"+str(Pieces.index(Pi))

    def gui_gmsh_meshing(self):
	import re
	line = self.le_cmd_line_opt_mesh.text()
	args=[i for i in re.split('\n|\ |:|=',line) if i]
	print "gmsh meshing .."
	print args
	if line=="":
	    Pi.ng2D.NGParamSetMaxSize="2.2"
	    Pi.ng2D.NGParamSetMinSize="0.1" 
	    Pi.ng2D.gmshalgoname="auto"
	if args[0]=="gmsh":
	    Pi.ng2D.NGParamSetMaxSize=args[1]
	    Pi.ng2D.NGParamSetMinSize=args[2] 
	    Pi.ng2D.gmshalgoname=args[3]
	    print args[2]
	Pi.femmesh1=pointtopost.gmshmesh(Pi.compound1, Pi.ng2D)
	Pi.femmesh1.Label=Pi.femmesh1name+"Pi"+str(Pieces.index(Pi))

	print "make mb egdes"
	#Pi.comp_mb_edges=pointtopost.make_mb_edge(Pi.femmesh1)
	#buggy ... 
	#Pi.comp_mb_edges.Label=Pi.comp_mb_edgesstr+"Pi"+str(Pieces.index(Pi))
	
	Pi.comp_topo_edges=pointtopost.make_topo_edge(Pi.compound1)
	Pi.comp_topo_edges.Label=Pi.comp_topo_edgesstr+"Pi"+str(Pieces.index(Pi))


    def gui_annotate_all(self):
	#annotate all elements
	cmd_line_opt = self.le_cmd_line_opt_flag.text()
	print cmd_line_opt
	selection = FreeCADGui.Selection.getSelection()
	if selection and (cmd_line_opt[len(cmd_line_opt)-2]=="1") :
	    Pi.femmesh1=selection[0]
	    print "read femmesh1 from selection"
	anno1=pointtopost.visu_annotate_element(Pi.femmesh1.FemMesh)
	anno1.Label="Ann_all_Face_"+"Pi"+str(Pieces.index(Pi))
	anno1.ViewObject.hide()
	anno1.ViewObject.show()
	anno1.ViewObject.hide()

	#annotate all nodes
	anno2=pointtopost.visu_annotate_note(Pi.femmesh1)
	anno2.Label="Ann_all_N_"+"Pi"+str(Pieces.index(Pi))
	anno2.ViewObject.hide()
	anno2.ViewObject.show()
	anno2.ViewObject.hide()

	#annotate all mesh boundary edges
	anno3=pointtopost.visu_annotate_edge_element(Pi.femmesh1.FemMesh)
	anno3.Label="Ann_mb_E_"+"Pi"+str(Pieces.index(Pi))
	anno3.ViewObject.hide()
	anno3.ViewObject.show()
	anno3.ViewObject.hide()


    def gui_annotate_doubles(self):
	#doubles elimination start
	#
	cmd_line_opt = self.le_cmd_line_opt_flag.text()
	print cmd_line_opt
	selection = FreeCADGui.Selection.getSelection()
	if selection and (cmd_line_opt[len(cmd_line_opt)-2]=="1") :
	    print "read femmesh1 from selection"
	    Pi.femmesh1=selection[0]
	Pi.dnL=pointtopost.checkfordoublenodes(Pi.femmesh1.FemMesh)
	#annotate double nodes
	anno4=pointtopost.visu_annotate_note(Pi.femmesh1,Pi.dnL[0])
	anno4.Label="Ann_double_N_"+"Pi"+str(Pieces.index(Pi))
	anno4.ViewObject.hide()
	anno4.ViewObject.show()
	anno4.ViewObject.hide()
	Pi.dnE=pointtopost.finddoubleedges(Pi.femmesh1)

	#annotate double edges
	anno5=pointtopost.visu_annotate_edge_element(Pi.femmesh1.FemMesh, [i[3] for i in Pi.dnE])
	anno5.Label="Ann_double_E_"+"Pi"+str(Pieces.index(Pi))
	anno5.ViewObject.hide()
	anno5.ViewObject.show()
	anno5.ViewObject.hide()


    def gui_doubles_elimination(self):
	Pi.dnL=pointtopost.checkfordoublenodes(Pi.femmesh1.FemMesh)
	Pi.dnE=pointtopost.finddoubleedges(Pi.femmesh1)
	Pi.edgeL=mark_deleted_edges(Pi.femmesh1,[i[3] for i in Pi.dnE])

	Pi.nodeL=mark_deleted_nodes(Pi.femmesh1,Pi.dnL[2])

	Pi.facesE=pointtopost.rereference_elments(Pi.femmesh1,Pi.dnL[2],Pi.edgeL)

	Pi.femmesh2=pointtopost.rebuild_mesh(Pi.femmesh1,Pi.nodeL,Pi.facesE)
	Pi.femmesh2.Label=Pi.femmesh2name+"Pi"+str(Pieces.index(Pi))


	dn2L=pointtopost.checkfordoublenodes(Pi.femmesh2.FemMesh)
	print dn2L
	#0 doubles 
	#
	#doubles elimination end
	pass

    def gui_register_bodies_boundaries(self):
	#get nodes of edges
	Pi.egdeN=pointtopost.getnodesbycompoundedge(Pi.femmesh2,Pi.comp_topo_edges)

	#get nodes of face=body
	Pi.faceN=pointtopost.getnodesbycompoundface(Pi.femmesh2,Pi.compound0)

	#register bodies and boundaries with default
	Pi.bnd_tegdeL=[[1,3],[18]]
	Pi.bnd_tegdeL, Pi.Bnds, Pi.Bodies= pointtopost.register_bodies_and_boundaries(Pi.bnd_tegdeL,Pi.Bodies,Pi.Bnds,Pi.compound0)

	#get nodes of boundary condition
	Pi.boundaries=pointtopost.get_bnd_nodesbytedge(Pi.femmesh2,Pi.comp_topo_edges,Pi.bnd_tegdeL)

	#compound links colored according to bondary group
	pointtopost.visu_bnd_tedge(Pi.comp_topo_edges,Pi.bnd_tegdeL,Pi.Bnds)

	Pi.bodyflag=get_elementbodysflag(Pi.femmesh2,Pi.compound0,Pi.faceN) 

	Pi.egdegroup=pointtopost.get_edgegroup_and_neighbor(Pi.femmesh2,Pi.compound0,Pi.faceN,Pi.boundaries)
	pass
    
    def gui_init_reg_bnd(self):
	
	#register workflow piece from bodies and boundaries with hardcoded default
	Pi.bnd_tegdeL=[[1,3],[18]]
	Pi.bnd_tegdeL, Pi.Bnds, Pi.Bodies= pointtopost.register_bodies_and_boundaries(Pi.bnd_tegdeL,Pi.Bodies,Pi.Bnds,Pi.compound0)
	#write bodies and boundaries from pi to spread
	Pi.spreedsheet,Pi.Bodies,Pi.Bnds,Pi.bnd_tegdeL=pointtopost.write_bnd_pi_to_spreadsheet(Pi.bnd_tegdeL,Pi.Bnds,Pi.Bodies,Pi.spreedsheet)
	Pi.spreedsheet.Label=Pi.spreedsheetstr+"Pi"+str(Pieces.index(Pi))
	#write spreadsh to csv
	pointtopost.open_spreadsh_csv(Pi.spreedsheet,Pi.csvfile,"write")
	
	#visualize boundaries
	# colors and annotate boundary edges
	pointtopost.visu_bnd_tedge(Pi.comp_topo_edges,Pi.bnd_tegdeL,Pi.Bnds)

	#viuaalize bodies
	visu_bnd_bodies(Pi.compound0,Pi.Bodies)

	print "hellospreedsheet "
	
    def gui_reg_save(self):
	print "reg_savE"#
	cmd_line_opt = self.le_cmd_line_opt_flag.text()
	#3. last index 1? read cvs else read spread, updata the rest
	if (cmd_line_opt[len(cmd_line_opt)-3]=="1"):
	    pointtopost.open_spreadsh_csv(Pi.spreedsheet,Pi.csvfile,"read")
	    #write spreadsh to pi
	    Pi.spreedsheet,Pi.Bodies,Pi.Bnds,Pi.bnd_tegdeL=pointtopost.write_bnd_pi_to_spreadsheet(Pi.bnd_tegdeL,Pi.Bnds,Pi.Bodies,Pi.spreedsheet, "read")	    
	else:
	    #write spreadsh to pi: case user edits internal spreadsheet
	    Pi.spreedsheet,Pi.Bodies,Pi.Bnds,Pi.bnd_tegdeL=pointtopost.write_bnd_pi_to_spreadsheet(Pi.bnd_tegdeL,Pi.Bnds,Pi.Bodies,Pi.spreedsheet, 	    "read")	    
	    #write  spreadsh to csv
	    pointtopost.open_spreadsh_csv(Pi.spreedsheet,Pi.csvfile,"write")
	
	
	#visualize boundaries
	# colors and annotate boundary edges
	pointtopost.visu_bnd_tedge(Pi.comp_topo_edges,Pi.bnd_tegdeL,Pi.Bnds)

	#viusalize bodies
	visu_bnd_bodies(Pi.compound0,Pi.Bodies)	
	### append calculation part
	#get nodes of edges
	Pi.egdeN=pointtopost.getnodesbycompoundedge(Pi.femmesh2,Pi.comp_topo_edges)
	#get nodes of face=body
	Pi.faceN=pointtopost.getnodesbycompoundface(Pi.femmesh2,Pi.compound0)
	#get nodes of boundary condition
	Pi.boundaries=pointtopost.get_bnd_nodesbytedge(Pi.femmesh2,Pi.comp_topo_edges,Pi.bnd_tegdeL)
	Pi.bodyflag=get_elementbodysflag(Pi.femmesh2,Pi.compound0,Pi.faceN)
	Pi.egdegroup=pointtopost.get_edgegroup_and_neighbor(Pi.femmesh2,Pi.compound0,Pi.faceN,Pi.boundaries)
	return
    
    def gui_annotate_boundary_neighbor_and_edgegroup(self):
	pass
	#annotate boundary neighbor cells
	anno5=pointtopost.visu_annotate_element(Pi.femmesh2.FemMesh,Pi.egdegroup[1],Pi.bodyflag)
	anno5.Label="Ann_bnd_neigh_cells_"+"Pi"+str(Pieces.index(Pi))
	anno5.ViewObject.hide()
	anno5.ViewObject.show()
	anno5.ViewObject.hide()

	#annotate boundary edges with edgegroup
	anno6=pointtopost.visu_annotate_edge_element(Pi.femmesh2.FemMesh,[],Pi.egdegroup[0])
	anno6.Label="Ann_bndgroup_E_"+"Pi"+str(Pieces.index(Pi))
	anno6.ViewObject.hide()
	anno6.ViewObject.show()
	anno6.ViewObject.hide()

	#mesh preperation done

    def gui_export_to_elmer(self):
	#writing sif file
	s=pointtopost.write_elmer_sif_file(Pi.siftemplfile,Pi.siffile,Pi.Bodies,Pi.Bnds)
	pass

    def gui_writing_sif_file(self):
	pointtopost.process_elmer_sif_file(Pi.siffile,Pi.epsourcefile,Pi.fempath,1)

	pass
	
    def gui_fem_process(self):
	Pi.solutionheader, Pi.solutiondata, Pi.headerline=pointtopost.read_ep_result(Pi.epfile)

	pass

    def gui_annotate_t_results(self):
	pass
	#coloring by Temperaturescale
	pointtopost.gradient_color_mesh(Pi.solutiondata[0][0],Pi.femmesh2)

	#annotate T-Results
	anno7=pointtopost.visu_annotate_note(Pi.femmesh2,[],["T:"+str(round(float(j),2)) for j in Pi.solutiondata[0][0]])
	anno7.Label="Ann_resultT_N_"+"Pi"+str(Pieces.index(Pi))
	anno7.ViewObject.hide()
	anno7.ViewObject.show()
	anno7.ViewObject.hide()

    def gui_removeobjectswithchildren(self):
	selection = FreeCADGui.Selection.getSelection()
	if selection:
	    print "delete selected"
	    docobj2L=selection
	    pointtopost.removeobjectswithchildren(docobj2L)
	
	

	
	


#init pointtopost
import pointtopost
from pointtopost import *
Pieces=[]
i=0
Pieces.append(Piece)
Pi=Pieces[i]
pointtopost.testinit151024(Pi) #default

mw = FreeCADGui.getMainWindow()
d = QtGui.QDockWidget()
d1=d.setWidget(MeshGmsh())
d.toggleViewAction().setText("Gmsh")
d.setAttribute(QtCore.Qt.WA_DeleteOnClose)
d.setWindowTitle(" 2D FEM multi boody heat conduction ") 
mw.addDockWidget(QtCore. Qt.RightDockWidgetArea, d)

# END OF MACRO
